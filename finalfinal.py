# -*- coding: utf-8 -*-
"""Copy of FinalFinal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ccAlMArJx5S-VMZHGBjhjDssHwFVhxJF
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')
# %matplotlib inline
from matplotlib.pyplot import xticks
import plotly.express as px
import plotly.graph_objects as go
import plotly.figure_factory as ff
from plotly.subplots import make_subplots

df=pd.read_csv('/content/drive/MyDrive/Hackathon/agricultural_yield_test.csv')

insu=df.select_dtypes(include=["number"]) # taking only columns which has number in it as string is not used in heatmap
sns.heatmap(insu.corr(),cmap='coolwarm',annot=True)
plt.show()

df

from plotly.offline import iplot

fig = px.box(x = df['Sunny_Days'],
             labels={"x": "Pesticides"},
             title="Pesticides_Quantity")
iplot(fig)

import numpy as np

# Calculate Q1, Q3, and IQR
Q25 = np.quantile(df['Sunny_Days'], q=0.25)
Q75 = np.quantile(df['Sunny_Days'], q=0.75)
IQR = Q75 - Q25

# Calculate lower and upper bounds
lower_bound = Q25 - 1.5 * IQR
upper_bound = Q75 + 1.5 * IQR

# Cap the outliers
df['Sunny_Days'] = np.where(df['Sunny_Days'] < lower_bound, lower_bound, df['Sunny_Days'])
df['Sunny_Days'] = np.where(df['Sunny_Days'] > upper_bound, upper_bound, df['Sunny_Days'])

from plotly.offline import iplot

fig = px.box(x = df['Rainfall_mm'],
             labels={"x": "Pesticides"},
             title="Pesticides_Quantity")
iplot(fig)

import numpy as np

# Calculate Q1, Q3, and IQR
Q25 = np.quantile(df['Rainfall_mm'], q=0.25)
Q75 = np.quantile(df['Rainfall_mm'], q=0.75)
IQR = Q75 - Q25

# Calculate lower and upper bounds
lower_bound = Q25 - 1.5 * IQR
upper_bound = Q75 + 1.5 * IQR

# Cap the outliers
df['Rainfall_mm'] = np.where(df['Rainfall_mm'] < lower_bound, lower_bound, df['Rainfall_mm'])
df['Rainfall_mm'] = np.where(df['Rainfall_mm'] > upper_bound, upper_bound, df['Rainfall_mm'])

from plotly.offline import iplot

fig = px.box(x = df['Irrigation_Schedule'],
             labels={"x": "Pesticides"},
             title="Pesticides_Quantity")
iplot(fig)

import numpy as np

# Calculate Q1, Q3, and IQR
Q25 = np.quantile(df['Irrigation_Schedule'], q=0.25)
Q75 = np.quantile(df['Irrigation_Schedule'], q=0.75)
IQR = Q75 - Q25

# Calculate lower and upper bounds
lower_bound = Q25 - 1.5 * IQR
upper_bound = Q75 + 1.5 * IQR

# Cap the outliers
df['Irrigation_Schedule'] = np.where(df['Irrigation_Schedule'] < lower_bound, lower_bound, df['Irrigation_Schedule'])
df['Irrigation_Schedule'] = np.where(df['Irrigation_Schedule'] > upper_bound, upper_bound, df['Irrigation_Schedule'])

from plotly.offline import iplot

fig = px.box(x = df['Irrigation_Schedule'],
             labels={"x": "Pesticides"},
             title="Pesticides_Quantity")
iplot(fig)

df.shape

df.describe()

df.info()

df

df["Fertilizer"]=df["Fertilizer_Amount_kg_per_hectare"].apply(lambda x : "Less" if x < 100
                                                     else ("Medium" if 100 <= x < 200
                                                           else "High"))
df["Fertilizer"].value_counts()

plt.figure(figsize=(6, 4))
sns.countplot(x=df["Fertilizer"], palette="viridis")


plt.xlabel("Fertilizer Level")
plt.ylabel("Count")
plt.title("Count of Irrigation Levels")

plt.show()

sns.barplot(x=df["Fertilizer"], y=df["Yield_kg_per_hectare"], palette="magma")
plt.title("Effect of Fertilizer on Yield")
plt.xlabel("Fertilizer effect on Yield")
plt.ylabel("Yield (kg/hectare)")
plt.show()

sns.barplot(x=df["Seed_Variety"], y=df["Yield_kg_per_hectare"], palette="magma")
plt.title("Effect of Seed Variety on Yield")
plt.xlabel("Seed Variety(0 for High yield and 1 for Low Yield)")
plt.ylabel("Yield (kg/hectare)")
plt.show()

sns.scatterplot(x=df["Sunny_Days"], y=df["Yield_kg_per_hectare"], color="green")
plt.title("Impact of Sunny Days on Yield")
plt.show()

sns.violinplot(x=df["Irrigation_Schedule"], y=df["Yield_kg_per_hectare"], palette="coolwarm")
plt.title("Irrigation Schedule vs. Yield Distribution")
plt.show()

sns.histplot(df["Fertilizer_Amount_kg_per_hectare"], bins=30, kde=True, color="purple")
plt.title("Distribution of Fertilizer Usage")
plt.xlabel("Fertilizer Amount (kg per hectare)")
plt.show()

sns.violinplot(x=df["Irrigation_Schedule"], y=df["Sunny_Days"], palette="coolwarm")
plt.title("Sunny Days vs. Irrigation Schedule")
plt.show()

fig = px.bar(df, x='Irrigation_Schedule', y='Yield_kg_per_hectare', color='Seed_Variety', height=400,template='simple_white')
fig.show()



df["Irrigation"]=df["Irrigation_Schedule"].apply(lambda x : "Less" if x < 4
                                                     else ("Medium" if 4 <= x < 7
                                                           else "High"))

plt.figure(figsize=(6, 4))
sns.countplot(x=df["Irrigation"], palette="viridis")


plt.xlabel("Irrigation Level")
plt.ylabel("Count")
plt.title("Count of Irrigation Levels")

plt.show()

df

grouped_df = df.groupby(['Seed_Variety', 'Irrigation']).size().reset_index(name='count')
grouped_df = grouped_df.sort_values(by='count', ascending=False)


fig = px.bar(grouped_df,
             y='Irrigation',
             x='count',
             color='Seed_Variety',
             title=f"Count by Irrigation and Seed_Variety (Total Data: {grouped_df['count'].sum()})",
             labels={'count': 'Number of Data'},
             text_auto=True,
             color_discrete_sequence=px.colors.qualitative.Set3,
             hover_data={'Irrigation': True, 'Seed_Variety': True, 'count': True})

fig.update_layout(
    font=dict(size=14),
    title_font=dict(size=20),
    legend_title='Thal Type',
    plot_bgcolor='rgba(245,245,245,0.4)'
)

fig.show()

df.columns

sns.distplot(df['Yield_kg_per_hectare'])

X=df[["Seed_Variety","Irrigation_Schedule","Soil_Quality","Fertilizer_Amount_kg_per_hectare","Sunny_Days","Rainfall_mm"]]
Y=df["Yield_kg_per_hectare"]

from sklearn.model_selection import train_test_split
X_train,X_test,Y_train,Y_test=train_test_split(X,Y,train_size=0.8 ,random_state=120)

import statsmodels.api as sm

# adding a constant to get an intercept
X_train_sm=sm.add_constant(X_train)

#now, fitting the regresion line using OLS (ordinary least Squares)
lr=sm.OLS(Y_train,X_train_sm).fit()

lr.params

print(lr.summary())

from sklearn.metrics import mean_squared_error
from sklearn.metrics import r2_score

X_test_sm=sm.add_constant(X_test)
y_pred=lr.predict(X_test_sm)

np.sqrt(mean_squared_error(Y_test,y_pred))

r_squared=r2_score(Y_test,y_pred)
r_squared

# formula=297.9103*Seed_Variety + Irrigation_Schedule* 50.8534 + Soil_Quality * 1.4919 + Fertilizer_Amount_kg_per_hectare  *  0.7990  + Sunny_Days*1.9130 + Rainfall_mm *-0.4889 +50.9103